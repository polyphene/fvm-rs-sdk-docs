var suggestions=document.getElementById("suggestions"),search=document.getElementById("search");search!==null&&document.addEventListener("keydown",inputFocus);function inputFocus(e){e.ctrlKey&&e.key==="/"&&(e.preventDefault(),search.focus()),e.key==="Escape"&&(search.blur(),suggestions.classList.add("d-none"))}document.addEventListener("click",function(e){var t=suggestions.contains(e.target);t||suggestions.classList.add("d-none")}),document.addEventListener("keydown",suggestionFocus);function suggestionFocus(e){const s=suggestions.classList.contains("d-none");if(s)return;const t=[...suggestions.querySelectorAll("a")];if(t.length===0)return;const n=t.indexOf(document.activeElement);if(e.key==="ArrowUp"){e.preventDefault();const s=n>0?n-1:0;t[s].focus()}else if(e.key==="ArrowDown"){e.preventDefault();const s=n+1<t.length?n+1:n;t[s].focus()}}(function(){var e=new FlexSearch.Document({tokenize:"forward",cache:100,document:{id:"id",store:["href","title","description"],index:["title","description","content"]}});e.add({id:0,href:"/fvm-rs-sdk-docs/docs/reference/",title:"Reference",description:"",content:""}),e.add({id:1,href:"/fvm-rs-sdk-docs/docs/reference/usage/",title:"Usage",description:`You may find the sources of the FVM Rust SDK here.
Limitations #As of now some references to ref-fvm are done through cargo patches to ease the development of the SDK. This reference makes the SDK harder to use and to test through integration in a Filecoin Virtual Machine. However, the final version will be simply a line in your dependencies so please bear with us until then!`,content:` You may find the sources of the FVM Rust SDK here.
Limitations #As of now some references to ref-fvm are done through cargo patches to ease the development of the SDK. This reference makes the SDK harder to use and to test through integration in a Filecoin Virtual Machine. However, the final version will be simply a line in your dependencies so please bear with us until then!
Pre-requirements #Before using the SDK, clone this repository on your local machine and make sure to initialize and update the ref-fvm submodule.
git submodule init git submodule update Build an actor using the SDK #To build an actor using the SDK you can follow the example of the sdk_example_actor crate in ./examples/sdk-example-actor. Once your actor\u0026rsquo;s crate is ready just run:
cargo build Using wasm-builder in your build.rs file will compile the crate in a wasm file that can be found at the path ./examples/\u0026lt;crate-folder\u0026gt;/target/debug/wbuild/\u0026lt;crate-name\u0026gt;/\u0026lt;crate-name\u0026gt;.compact.wasm.
Test your actor #You can test your actor by either integrate it in the fvm_integration_tests crate in ref-fvm or by running your actor on a local lotus network.
Integration test framework #Create a new test in the fvm_integration_tests crate and use the path of the compiled wasm file to retrieve its binary content. You will then be able to interact with it. An example of such tests can be found in \u0026lt;ref-fvm-repository\u0026gt;/testing/integation/tests.
Lotus local network #Set up a Lotus devnet on the branch experimental/fvm-m2. Instructions can be found in the documentation. Install the actor on the lotus devnet, lotus chain install-actor \u0026lt;path-to-wasm-bytecode\u0026gt;. This command should return the CID representing the bytecode of the actor. Instantiate the actor, lotus chain create-actor \u0026lt;code-cid\u0026gt; \u0026lt;encoded-params\u0026gt;. This command should return the address at which the actor is instantiated. Invoke any function from your actor, lotus chain invoke \u0026lt;address\u0026gt; \u0026lt;method-num\u0026gt; `}),e.add({id:2,href:"/fvm-rs-sdk-docs/docs/reference/procedural-macros/",title:"Procedural Macros",description:`fvm_state #To import in your actor everything needed by the procedural macro it is recommended to use the whole state module:
use fvm_rs_sdk::state::*; The macro should be used on a public structure. It will generate an implementation of the StateObject for the state object, allowing for it to be saved and loaded while interacting with the actor.
A simple example of usage would be:
use fvm_rs_sdk::state::*; #[fvm_state] pub struct State { pub count: u64 } Blockstore glue code is located in the SDK and can be found under the state module of the crate.`,content:`fvm_state #To import in your actor everything needed by the procedural macro it is recommended to use the whole state module:
use fvm_rs_sdk::state::*; The macro should be used on a public structure. It will generate an implementation of the StateObject for the state object, allowing for it to be saved and loaded while interacting with the actor.
A simple example of usage would be:
use fvm_rs_sdk::state::*; #[fvm_state] pub struct State { pub count: u64 } Blockstore glue code is located in the SDK and can be found under the state module of the crate.
Limitations #The procedural macro does not work on structure with lifetime or generic parameters to prevent problems around Serialization and Deserialization. When using the macro on a structure, fields that are not public will not be stored in the state. fvm_actor #The procedural macro to annotate your actor\u0026rsquo;s interface can be found in the actor module:
use fvm_rs_sdk::actor::fvm_actor; This macro will parse the annotated implementation and generate a proper invoke() function that will become the entry point of your actor. An #[fvm_actor] procedural macro should be combined with the usage of the #[fvm_export] macro described in the next section.
A simple usage would be:
use fvm_rs_sdk::state::*; use fvm_rs_sdk::actor::fvm_actor; #[fvm_state] pub struct State { pub count: u64 } #[fvm_actor] impl State { ... } Limitations #The implementation with #[fvm_actor] has to be the implementation of the structure annotated with #[fvm_state]. Only one implementation can be annotated with #[fvm_actor] as it will otherwise generate compilation conflicts (multiple invoke() functions declared). Currently, the only dispatch method handled is method-num, using integers to manage the internal dispatch of the actor. Implementation with generics or lifetime are not supported. fvm_export #The procedural macro to annotate your actor\u0026rsquo;s entry point in the implementation representing your actor\u0026rsquo;s interface. It can be accessed in the actor module:
use fvm_rs_sdk::actor::fvm_export; This macro will help to generate the glue code inside the invoke() entry point by generating all internal dispatch possibilities.
A simple usage would be:
use fvm_rs_sdk::state::*; use fvm_rs_sdk::actor::{fvm_actor, fvm_export}; #[fvm_state] pub struct State { pub count: u64 } #[fvm_actor] impl State { #[fvm_export(binding=1)] fn increment(\u0026amp;mut self) -\u0026gt; u64 { self.count += 1; self.count } } It has to be noted that we are differentiating pure, read-only and read-write functions by playing around the reference that a method is associated with. As such:
No reference: pure function \u0026amp;self: read-only function \u0026amp;mut self: read-write function Limitations #When specifying an export it has to be used with the binding attribute to specify its internal dispatch value (e.g.: #[fvm_export(binding=1)]). Methods with generic types or lifetimes as arguments or return are not supported. fvm_payload #This procedural macro should be used on custom structures and types that will be used either as parameters or return types of method exported. It can be found in the payload module of the crate. It is recommended to use the whole module when dealing with the macro:
use fvm_rs_sdk::payload::*; It will generate necessary code for Serialization and Deserialization of the structures and types. As serde is working recursively on types within structures, all inner types should also be tagged with the macro.
A simple usage would be:
use fvm_rs_sdk::state::*; use fvm_rs_sdk::actor::{fvm_actor, fvm_export}; use fvm_rs_sdk::payload::fvm_payload; #[fvm_state] pub struct State { pub count: u64 } #[fvm_payload] pub struct Payload { pub amount: u64 } #[fvm_actor] impl State { #[fvm_export(binding=1)] fn increment(\u0026amp;mut self) -\u0026gt; u64 { self.count += 1; self.count } #[fvm_export(binding=2)] fn add(\u0026amp;mut self, payload: Payload) -\u0026gt; u64 { self.count += payload.amount; self.count } } `}),e.add({id:3,href:"/fvm-rs-sdk-docs/docs/",title:"Docs",description:"",content:""}),search.addEventListener("input",t,!0);function t(){const s=5;var n=this.value,o=e.search(n,{limit:s,enrich:!0});const t=new Map;for(const e of o.flatMap(e=>e.result)){if(t.has(e.doc.href))continue;t.set(e.doc.href,e.doc)}if(suggestions.innerHTML="",suggestions.classList.remove("d-none"),t.size===0&&n){const e=document.createElement("div");e.innerHTML=`No results for "<strong>${n}</strong>"`,e.classList.add("suggestion__no-results"),suggestions.appendChild(e);return}for(const[r,a]of t){const n=document.createElement("div");suggestions.appendChild(n);const e=document.createElement("a");e.href=r,n.appendChild(e);const o=document.createElement("span");o.textContent=a.title,o.classList.add("suggestion__title"),e.appendChild(o);const i=document.createElement("span");if(i.textContent=a.description,i.classList.add("suggestion__description"),e.appendChild(i),suggestions.appendChild(n),suggestions.childElementCount==s)break}}})()