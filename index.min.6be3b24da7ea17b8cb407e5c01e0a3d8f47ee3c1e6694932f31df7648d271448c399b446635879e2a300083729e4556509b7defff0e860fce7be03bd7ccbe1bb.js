var suggestions=document.getElementById("suggestions"),search=document.getElementById("search");search!==null&&document.addEventListener("keydown",inputFocus);function inputFocus(e){e.ctrlKey&&e.key==="/"&&(e.preventDefault(),search.focus()),e.key==="Escape"&&(search.blur(),suggestions.classList.add("d-none"))}document.addEventListener("click",function(e){var t=suggestions.contains(e.target);t||suggestions.classList.add("d-none")}),document.addEventListener("keydown",suggestionFocus);function suggestionFocus(e){const s=suggestions.classList.contains("d-none");if(s)return;const t=[...suggestions.querySelectorAll("a")];if(t.length===0)return;const n=t.indexOf(document.activeElement);if(e.key==="ArrowUp"){e.preventDefault();const s=n>0?n-1:0;t[s].focus()}else if(e.key==="ArrowDown"){e.preventDefault();const s=n+1<t.length?n+1:n;t[s].focus()}}(function(){var e=new FlexSearch.Document({tokenize:"forward",cache:100,document:{id:"id",store:["href","title","description"],index:["title","description","content"]}});e.add({id:0,href:"/docs/reference/",title:"Reference",description:"",content:""}),e.add({id:1,href:"/docs/reference/considerations/",title:"Considerations",description:`You can find the initial grant proposal for the high level Rust SDK 1.0 here
External considerations #The goal for this SDK was to create a set of tools that would help actors developer to get on building over the Filecoin network without having to think about overhead code used to comply to the network standard.
In that sense the SDK is meant to be:
Simple: Entry-level Rust developer should be able to use the SDK to produce actors that can be run in the FVM.`,content:` You can find the initial grant proposal for the high level Rust SDK 1.0 here
External considerations #The goal for this SDK was to create a set of tools that would help actors developer to get on building over the Filecoin network without having to think about overhead code used to comply to the network standard.
In that sense the SDK is meant to be:
Simple: Entry-level Rust developer should be able to use the SDK to produce actors that can be run in the FVM. Adjustable: More experienced developer, either in Rust or on IPFS \u0026amp; Filecoin knowledge, should be able to fine-tune some part of the SDK to fit their needs (e.g.: codec for methods payloads). Modular: For some use cases only a small amount of utilities will be required while other projects will need a fully assisted experience. Developer should be able to find utilities for all types of needs emerging when dealing with actor developments. Internal considerations #As of now the FVM and its ecosystem are still evolving, which requires its tooling framework to evolve at the same pace. This SDK was designed with those considerations in mind. All procedural macros and modules have been designed to evolve easily with future needs of integration based on community feedbacks (e.g. new binding style for methods).
`}),e.add({id:2,href:"/docs/reference/usage/",title:"Usage",description:`You may find the sources of the FVM Rust SDK here.
Limitations #As of now some references to ref-fvm are done through cargo patches to ease the development of the SDK. This reference makes the SDK harder to use and to test through integration in a Filecoin Virtual Machine. However, the final version will be simply a line in your dependencies so please bear with us until then!`,content:` You may find the sources of the FVM Rust SDK here.
Limitations #As of now some references to ref-fvm are done through cargo patches to ease the development of the SDK. This reference makes the SDK harder to use and to test through integration in a Filecoin Virtual Machine. However, the final version will be simply a line in your dependencies so please bear with us until then!
Pre-requirements #Before using the SDK, clone this repository on your local machine and make sure to initialize and update the ref-fvm submodule.
git submodule init git submodule update Build an actor using the SDK #To build an actor using the SDK you can follow the example of the sdk_example_actor crate in ./examples/sdk-example-actor. Once your actor\u0026rsquo;s crate is ready just run:
cargo build Using wasm-builder in your build.rs file will compile the crate in a wasm file that can be found at the path ./examples/\u0026lt;crate-folder\u0026gt;/target/debug/wbuild/\u0026lt;crate-name\u0026gt;/\u0026lt;crate-name\u0026gt;.compact.wasm.
Test your actor #You can test your actor by either integrate it in the fvm_integration_tests crate in ref-fvm or by running your actor on a local lotus network.
Integration test framework #Create a new test in the fvm_integration_tests crate and use the path of the compiled wasm file to retrieve its binary content. You will then be able to interact with it. An example of such tests can be found in \u0026lt;ref-fvm-repository\u0026gt;/testing/integation/tests.
Lotus local network #Set up a Lotus devnet on the branch experimental/fvm-m2. Instructions can be found in the documentation. Install the actor on the lotus devnet, lotus chain install-actor \u0026lt;path-to-wasm-bytecode\u0026gt;. This command should return the CID representing the bytecode of the actor. Instantiate the actor, lotus chain create-actor \u0026lt;code-cid\u0026gt; \u0026lt;encoded-params\u0026gt;. This command should return the address at which the actor is instantiated. Invoke any function from your actor, lotus chain invoke \u0026lt;address\u0026gt; \u0026lt;method-num\u0026gt; `}),e.add({id:3,href:"/docs/reference/procedural-macros/",title:"Procedural Macros",description:`fvm_state #To import in your actor everything needed by the procedural macro it is recommended to use the whole state module:
use fvm_rs_sdk::state::*; There are two things to know while using this procedural macro:
The procedural macro does not work on structure with lifetime or generic parameters to prevent problems around Serialization and Deserialization. When using the macro on a structure, fields that are not public will not be stored in the state.`,content:`fvm_state #To import in your actor everything needed by the procedural macro it is recommended to use the whole state module:
use fvm_rs_sdk::state::*; There are two things to know while using this procedural macro:
The procedural macro does not work on structure with lifetime or generic parameters to prevent problems around Serialization and Deserialization. When using the macro on a structure, fields that are not public will not be stored in the state. fvm_actor #The procedural macro to annotate your actor\u0026rsquo;s interface can be found in the actor module:
use fvm_rs_sdk::actor::fvm_actor; This macro will parse the annotated implementation and generate a proper invoke() function that will become the entry point of your actor.
Limitations #The implementation with #[fvm_actor] have to be the implementation of the structure with #[fvm_state]. Only one implementation can be written with #[fvm_actor] as it will generate compilation conflicts otherwise (multiple invoke() functions declared). Implementation with generics or lifetime are not supported. fvm_export #The procedural macro to annotate your actor\u0026rsquo;s entry point in the implementation representing your actor\u0026rsquo;s interface. It can be accessed in the actor module:
use fvm_rs_sdk::actor::fvm_export; Limitations #When specifying an export it has to be used with a valid binding method attribute to specify its internal dispatch value (e.g.: #[fvm_export(method_num=1)]). Currently the only supported binding method is method_num. A method annotated with #[fvm_export] has to be public. Methods with generic types or lifetimes as arguments or return are not supported. Only a \u0026ldquo;few\u0026rdquo; types are supported. The list can be found here. fvm_payload ##[fvm_payload] is used to annotate custom structures that will be used either as parameters or return value for exposed methods. To use the macro it is advised to import the whole payload module:
use fvm_rs_sdk::payload::*; There are two things to know while using this procedural macro:
The procedural macro does not work on structure with lifetime or generic parameters to prevent problems around Serialization and Deserialization. `}),e.add({id:4,href:"/docs/reference/future-work/",title:"Future Work",description:`If you have any idea for iterations that you can not find in the list down below please feel free to open an issue on the repository.
fvm_actor #Developers should be able to develop their own invoke function without using #[fvm_actor] and still feel as less overhead as possible. Different design should be studied (macros for code generation of serde/dispatch/etc., code injection at dedicated places in the generated invoke \u0026hellip;) and one implemented.`,content:` If you have any idea for iterations that you can not find in the list down below please feel free to open an issue on the repository.
fvm_actor #Developers should be able to develop their own invoke function without using #[fvm_actor] and still feel as less overhead as possible. Different design should be studied (macros for code generation of serde/dispatch/etc., code injection at dedicated places in the generated invoke \u0026hellip;) and one implemented. fvm_export #Support the \u0026ldquo;Calling convention with hashed method name\u0026rdquo; for exported methods. Examples #The current fungible token example is not adequate for production usage and is mostly coming from Helix team\u0026rsquo;s work on their Filecoin library. When the library is live on crates.io we should switch to an example importing it and implementing it. Optimization #This SDK should be tested and benchmark to try and find optimization to reduce Wasm bytecode size and gas cost when running a method exposed. `}),e.add({id:5,href:"/docs/",title:"Docs",description:"",content:""}),search.addEventListener("input",t,!0);function t(){const s=5;var n=this.value,o=e.search(n,{limit:s,enrich:!0});const t=new Map;for(const e of o.flatMap(e=>e.result)){if(t.has(e.doc.href))continue;t.set(e.doc.href,e.doc)}if(suggestions.innerHTML="",suggestions.classList.remove("d-none"),t.size===0&&n){const e=document.createElement("div");e.innerHTML=`No results for "<strong>${n}</strong>"`,e.classList.add("suggestion__no-results"),suggestions.appendChild(e);return}for(const[r,a]of t){const n=document.createElement("div");suggestions.appendChild(n);const e=document.createElement("a");e.href=r,n.appendChild(e);const o=document.createElement("span");o.textContent=a.title,o.classList.add("suggestion__title"),e.appendChild(o);const i=document.createElement("span");if(i.textContent=a.description,i.classList.add("suggestion__description"),e.appendChild(i),suggestions.appendChild(n),suggestions.childElementCount==s)break}}})()